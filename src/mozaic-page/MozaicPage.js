import React , { useRef, useState, useEffect, useCallback  }from 'react';
import { useLocation } from 'react-router-dom';
import Typography from '@mui/material/Typography';
import CssBaseline from '@mui/material/CssBaseline';
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import Stack from '@mui/material/Stack';
import AppTheme from '../shared-theme/AppTheme';
import Tabs from '@mui/material/Tabs';
import Tab from '@mui/material/Tab';
import Slider from '@mui/material/Slider';
import Checkbox from '@mui/material/Checkbox';
import FormControlLabel from '@mui/material/FormControlLabel';
import ColorModeSelect from '../shared-theme/ColorModeSelect';
import { Link } from 'react-router-dom';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import PauseIcon from '@mui/icons-material/Pause';



export default function MozaicPage() {
  const location = useLocation();
  const savedFileName = 'mozit.mp4'; // Ï†ÑÎã¨Îêú savedFileName Î∞õÍ∏∞
  const videoUrl = savedFileName ? `http://localhost:8080/edit/videos/${savedFileName}` : null;

  // Ï∫îÎ≤ÑÏä§ÏôÄ ÎπÑÎîîÏò§ Ï∞∏Ï°∞
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 });
  const [value, setValue] = useState(0); // ÌÉ≠ ÏÉÅÌÉú Ï∂îÍ∞Ä
  const [detectionData, setDetectionData] = useState([]);
  const [isPlaying, setIsPlaying] = useState(false);
  const [videoDuration, setVideoDuration] = useState(0);
  const [sliderValue, setSliderValue] = useState(0); // Ïä¨ÎùºÏù¥Îçî Í∞íÏùÑ ÏÉÅÌÉúÎ°ú Í¥ÄÎ¶¨



  // Í∞Å ÌÉ≠Î≥Ñ ÏÉÅÌÉú Ï†ÄÏû•
  const [settings, setSettings] = useState({
    harmful: { mosaic: false, blur: false, intensity: 50, size: 100 },
    privacy: { mosaic: false, blur: false, intensity: 50, size: 100 },
    person: { mosaic: false, blur: false, intensity: 50, size: 100, checkedPeople: [] },
  });


  // Ï¥àÍ∏∞ Î°úÎìú Ïãú Î™®ÏûêÏù¥ÌÅ¨ Í∏∞Î≥∏ ÌôúÏÑ±Ìôî ÏÑ§Ï†ï
    useEffect(() => {
      setSettings(prevSettings => ({
        ...prevSettings,
        harmful: { mosaic: true, blur: false, intensity: 50, size: 50 },
        privacy: { mosaic: true, blur: false, intensity: 50, size: 50 },
        person: { mosaic: true, blur: false, intensity: 50, size: 50, checkedPeople: [] }
      }));
    }, []);



   // ‚úÖ Î™®ÏûêÏù¥ÌÅ¨ ÎòêÎäî Î∏îÎü¨ Ï§ë ÌïòÎÇòÎßå ÏÑ†ÌÉù Í∞ÄÎä•ÌïòÍ≤å Ìï®
   const handleCheckboxChange = (tab, effectType, event) => {
    setSettings(prevSettings => {
      const updatedSettings = { ...prevSettings };
      // effectTypeÏù¥ "mosaic"Ïù¥Î©¥ blurÎ•º ÎπÑÌôúÏÑ±Ìôî, Î∞òÎåÄÎèÑ ÎßàÏ∞¨Í∞ÄÏßÄ
      if (effectType === "mosaic") {
        updatedSettings[tab].mosaic = event.target.checked;
        if (event.target.checked) updatedSettings[tab].blur = false; // Î∏îÎü¨ ÎπÑÌôúÏÑ±Ìôî
      } else if (effectType === "blur") {
        updatedSettings[tab].blur = event.target.checked;
        if (event.target.checked) updatedSettings[tab].mosaic = false; // Î™®ÏûêÏù¥ÌÅ¨ ÎπÑÌôúÏÑ±Ìôî
      }
      return updatedSettings;
    });
  };
  

  // Ïä¨ÎùºÏù¥Îçî Ìï∏Îì§Îü¨
  const handleSliderChange2 = (tab, key) => (event, newValue) => {
    setSettings((prev) => ({
      ...prev,
      [tab]: { ...prev[tab], [key]: newValue },
    }));
  };

  // ÏÇ¨Îûå Ï≤¥ÌÅ¨Î∞ïÏä§ Ìï∏Îì§Îü¨ (ÏÇ¨Îûå ÌÉ≠ Ï†ÑÏö©)
  const handlePersonCheck = (person) => (event) => {
    setSettings((prev) => ({
      ...prev,
      person: {
        ...prev.person,
        checkedPeople: event.target.checked
          ? [...prev.person.checkedPeople, person]
          : prev.person.checkedPeople.filter((p) => p !== person),
      },
    }));
  };

  const handleTabChange2 = (_, newValue) => setValue(newValue);

  /* */

  const handleLoadedMetadata = () => {
    const video = videoRef.current;
    if (video) {
      setCanvasSize({
        width: video.videoWidth,
        height: video.videoHeight,
      });
      setVideoDuration(video.duration); // ÎπÑÎîîÏò§ Í∏∏Ïù¥ ÏÑ§Ï†ï
    }
  };

  const handlePlayPause = () => {
    const video = videoRef.current;
    if (video) {
      if (video.paused) {
        video.play().then(() => {
          setIsPlaying(true);
        }).catch(error => {
          console.error("Error playing the video:", error);
        });
      } else {
        video.pause();
        setIsPlaying(false);
      }
    }
  };




  const handleSliderChange = (event, newValue) => {
    setSliderValue(newValue); // Ïä¨ÎùºÏù¥Îçî Í∞í ÏóÖÎç∞Ïù¥Ìä∏
    const video = videoRef.current;
    video.currentTime = (newValue / 100) * videoDuration; // Ïä¨ÎùºÏù¥Îçî Í∞íÏóê ÎπÑÎ°ÄÌïòÏó¨ ÌòÑÏû¨ Ïû¨ÏÉù ÏãúÍ∞Ñ Ï°∞Ï†ï
  };



  const handleCanvasClick = () => {
  const video = videoRef.current;
  if (video) {
    if (video.paused) {
      handlePlayPause(); // Ïû¨ÏÉù
    } else {
      handlePlayPause(); // ÏùºÏãú Ï†ïÏßÄ
    }
  }
};

/*
   Ïû¨ÏÉùÎ∞î
          */
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const updateSlider = () => {
        const currentSliderValue = (video.currentTime / videoDuration) * 100; // ÎπÑÎîîÏò§ ÌòÑÏû¨ ÏãúÍ∞Ñ ÎπÑÏú®
        setSliderValue(currentSliderValue); // Ïä¨ÎùºÏù¥Îçî Í∞í ÏóÖÎç∞Ïù¥Ìä∏
      };
      
      video.addEventListener('timeupdate', updateSlider);
      return () => {
        video.removeEventListener('timeupdate', updateSlider);
      };
    }
  }, [videoDuration]);

  // Ï∫îÎ≤ÑÏä§Ïóê Ìà¨Î™ÖÌïú ÏÉâÏùÑ Í∑∏Î¶¨Îäî Ìï®Ïàò
  const drawTransparentOverlay = () => {
    const canvas = canvasRef.current;
    const context = canvas.getContext('2d');

    // Ï∫îÎ≤ÑÏä§ ÏÇ¨Ïù¥Ï¶à ÏÑ§Ï†ï
    canvas.width = canvasSize.width;
    canvas.height = canvasSize.height;

    // Ìà¨Î™ÖÌïú ÏÉâ ÏÇ¨Í∞ÅÌòï Í∑∏Î¶¨Í∏∞
    context.fillStyle = 'rgba(255, 255, 255, 0)'; // Î∞òÌà¨Î™Ö Îπ®Í∞ÑÏÉâ
    context.fillRect(0, 0, canvas.width, canvas.height);


    // Ï£ºÏñ¥ÏßÑ Ï¢åÌëúÏôÄ ÌÅ¨Í∏∞Î°ú ÎÑ§Î™® Î∞ïÏä§ Í∑∏Î¶¨Í∏∞
    const x = 938.0; // x Ï¢åÌëú
    const y = 335.0; // y Ï¢åÌëú
    const width = 118.0; // Î∞ïÏä§ ÎÑàÎπÑ
    const height = 144.0; // Î∞ïÏä§ ÎÜíÏù¥

    context.strokeStyle = 'red'; // Î∞ïÏä§ ÏÑ† ÏÉâÏÉÅ
    context.lineWidth = 2; // Î∞ïÏä§ ÏÑ† ÎëêÍªò
    context.strokeRect(x, y, width, height); // ÎÑ§Î™® Î∞ïÏä§ Í∑∏Î¶¨Í∏∞
  };


  // ‚úÖ Î™®ÏûêÏù¥ÌÅ¨ & Î∏îÎü¨Î•º Ï†ÅÏö©ÌïòÎäî Ìï®Ïàò
  const drawMosaicOrBlur = () => {
    const video = videoRef.current;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");
  
    if (!video || !ctx) return;
  
    canvas.width = canvasSize.width;
    canvas.height = canvasSize.height;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  
    const currentFrame = Math.floor(video.currentTime * 30);
    const currentDetections = detectionData.find(d => d.frame === currentFrame)?.detections || [];
  
    // üî• `settings[value]`Ïù¥ ÏóÜÏùÑ Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
    const effectSettings = settings[value] || { mosaic: true, blur: false };
  
    currentDetections.forEach(({ x, y, width, height }) => {
      if (effectSettings.mosaic) {
        applyMosaic(ctx, x, y, width, height);
      } else if (effectSettings.blur) {
        applyBlur(ctx, x, y, width, height);
      }
  
      ctx.strokeStyle = "black";
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, width, height);
    });
  };
  
  


  /*
     Î∏îÎü¨Ï≤òÎ¶¨
             */


     // ÌôîÎ©¥ Ï§ëÏïôÏóê Î∏îÎü¨ Î∞ïÏä§Î•º ÎùÑÏö∞Îäî Ìï®Ïàò
        const drawBlurBoxInCenter = () => {
          const canvas = canvasRef.current;
          const ctx = canvas.getContext('2d');

          // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
          canvas.width = canvasSize.width;
          canvas.height = canvasSize.height;

          // ÌôîÎ©¥ Ï§ëÏïôÏóê Î∏îÎü¨ Î∞ïÏä§Ïùò ÏúÑÏπòÏôÄ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
          const x = canvas.width / 4; // ÌôîÎ©¥Ïùò Í∞ÄÎ°ú Ï§ëÏïô
          const y = canvas.height / 4; // ÌôîÎ©¥Ïùò ÏÑ∏Î°ú Ï§ëÏïô
          const width = canvas.width / 2; // Î∏îÎü¨ Î∞ïÏä§Ïùò ÎÑàÎπÑ
          const height = canvas.height / 2; // Î∏îÎü¨ Î∞ïÏä§Ïùò ÎÜíÏù¥

          // Î∏îÎü¨ Ï≤òÎ¶¨ Ï†ÅÏö©
          applyBlur(ctx, x, y, width, height);
        };




 // ‚úÖ Î™®ÏûêÏù¥ÌÅ¨ & Î∏îÎü¨ Ï≤òÎ¶¨ Ìï®Ïàò
  const applyEffect = (ctx, x, y, width, height, effectType) => {
    if (effectType === "mosaic") {
      applyMosaic(ctx, x, y, width, height);
    } else if (effectType === "blur") {
      applyBlur(ctx, x, y, width, height);
    }
  };
  
  // ‚úÖ Î∏îÎü¨ Ï≤òÎ¶¨ Ìï®Ïàò Ï∂îÍ∞Ä
  const applyBlur = (ctx, x, y, width, height) => {
    ctx.save();
    ctx.filter = "blur(10px)"; // Î∏îÎü¨ Ìö®Í≥º Ï†ÅÏö©
    ctx.drawImage(canvasRef.current, x, y, width, height, x, y, width, height);
    ctx.restore();
  };
  

  // Î™®ÏûêÏù¥ÌÅ¨ Ï†ÅÏö© Ìï®Ïàò
const applyMosaic = (ctx, x, y, width, height, blockSize = 10) => {
  for (let i = 0; i < width; i += blockSize) {
    for (let j = 0; j < height; j += blockSize) {
      const pixel = ctx.getImageData(x + i, y + j, blockSize, blockSize);
      const avgColor = getAverageColor(pixel.data);
      
      ctx.fillStyle = `rgb(${avgColor.r}, ${avgColor.g}, ${avgColor.b})`;
      ctx.fillRect(x + i, y + j, blockSize, blockSize);
    }
  }
};
  
  // ÌèâÍ∑† ÏÉâÏÉÅÏùÑ Íµ¨ÌïòÎäî Ìï®Ïàò
  const getAverageColor = useCallback((pixelData) => {
    let r = 0, g = 0, b = 0;
    const pixelCount = pixelData.length / 4;
  
    for (let i = 0; i < pixelData.length; i += 4) {
      r += pixelData[i];
      g += pixelData[i + 1];
      b += pixelData[i + 2];
    }
  
    return {
      r: Math.floor(r / pixelCount),
      g: Math.floor(g / pixelCount),
      b: Math.floor(b / pixelCount),
    };
  }, []);
  
  useEffect(() => {
    const fetchDetections = async () => {
      try {
        const response = await fetch(`http://localhost:8080/edit/videos/${savedFileName}/info`);
        const data = await response.json();
        setDetectionData(data.detections); // JSON Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
      } catch (error) {
        console.error("Error fetching detection data:", error);
      }
    };
  
    fetchDetections();
  }, [savedFileName]);


 // ÎπÑÎîîÏò§ Ïû¨ÏÉù Ïãú Î™®ÏûêÏù¥ÌÅ¨ ÎòêÎäî Î∏îÎü¨ Ï†ÅÏö©
    useEffect(() => {
      let animationFrameId;
      const render = () => {
        if (videoRef.current?.paused || videoRef.current?.ended) return;
        drawMosaicOrBlur();
        animationFrameId = requestAnimationFrame(render);
      };

      if (videoRef.current) {
        videoRef.current.addEventListener("play", render);
      }

      return () => {
        videoRef.current?.removeEventListener("play", render);
        cancelAnimationFrame(animationFrameId);
      };
    }, [canvasSize, detectionData, settings]);

    useEffect(() => {
      const video = videoRef.current;
      if (video) {
        const render = () => {
          if (video.paused || video.ended) return;
          drawBlurBoxInCenter(); // Ï§ëÏïôÏóê Î∏îÎü¨ Î∞ïÏä§Î•º Í∑∏Î¶¨Í∏∞
          requestAnimationFrame(render); // Í≥ÑÏÜçÌï¥ÏÑú ÏóÖÎç∞Ïù¥Ìä∏
        };
    
        video.addEventListener('play', render);
        return () => {
          video.removeEventListener('play', render);
        };
      }
    }, [canvasSize]);
  

  const handleTabChange = (event, newValue) => {
    setValue(newValue);
  };

  return (
    <AppTheme sx={{ width: '100vw', height: '100vh', overflow: 'hidden' }}>
      <CssBaseline />
      <ColorModeSelect sx={{ position: 'fixed', top: '1rem', right: '1rem' }} />
      <Box sx={{ display: 'flex', height: '100%', padding: 2 }}>
        <Box sx={{ width: '75%', display: 'flex', flexDirection: 'column', alignItems: 'center', position: 'relative' }}>
          <Typography
            variant="h4"
            sx={{
              textAlign: 'center',
              marginTop: 4,
              color: 'text.primary',
            }}
          >
            Î™®ÏûêÏù¥ÌÅ¨ Ï≤òÎ¶¨Îêú ÎèôÏòÅÏÉÅ
          </Typography>
          {videoUrl ? (
            <>
              <video
                ref={videoRef}
                src={videoUrl}
                crossOrigin="anonymous"
                // controls
                onLoadedMetadata={handleLoadedMetadata}
                style={{
                  display: 'block',
                  width: '80%', // ÎπÑÎîîÏò§ ÎÑàÎπÑÎ•º 80%Î°ú ÏÑ§Ï†ï
                  height: 'auto', // ÎπÑÏú® Ïú†ÏßÄ
                  position: 'relative', // ÏúÑÏπò ÏÑ§Ï†ï
                  top: 0, // ÏÉÅÎã® Ï†ïÎ†¨
                  zIndex: 1, // ÎπÑÎîîÏò§Í∞Ä ÏúÑÏóê Ïò§ÎèÑÎ°ù ÏÑ§Ï†ï
                  marginBottom: '50px',
                }}
              />
              <canvas
                ref={canvasRef}
                width={canvasSize.width}
                height={canvasSize.height}
                onClick={handleCanvasClick}
                style={{
                  position: 'absolute', // Ï†àÎåÄ ÏúÑÏπòÎ°ú ÏÑ§Ï†ï
                  top: 0,
                  pointerEvents: 'auto', // Ï∫îÎ≤ÑÏä§Í∞Ä ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏Î•º Ï∞®Îã®ÌïòÏßÄ ÏïäÎèÑÎ°ù
                  zIndex: 2, // Ï∫îÎ≤ÑÏä§Í∞Ä ÎπÑÎîîÏò§ ÏúÑÏóê Ïò§ÎèÑÎ°ù ÏÑ§Ï†ï
                  width: '80%', // Ï∫îÎ≤ÑÏä§ ÎÑàÎπÑÎ•º ÎπÑÎîîÏò§ÏôÄ ÎèôÏùºÌïòÍ≤å ÏÑ§Ï†ï
                  height: 'auto', // ÏûêÎèôÏúºÎ°ú ÎÜíÏù¥ Ï°∞Ï†ï
                  top: '68px',
                }}
              />
              <Box
                sx={{
                  position: 'absolute',
                  bottom: '20px',
                  left: '20px',
                  right: '20px',
                  display: 'flex',
                  alignItems: 'center',
                  zIndex: 3,
                  backgroundColor: 'rgba(0, 0, 0, 0.5)', // Î∞òÌà¨Î™Ö Î∞∞Í≤Ω
                  borderRadius: '5px',
                  padding: '10px',
                }}
              >
                <Button onClick={handlePlayPause}>
                  {isPlaying ? <PauseIcon /> : <PlayArrowIcon />}
                </Button>
                <Slider
                  id="video-slider"
                  sx={{ marginLeft: '10px', flexGrow: 1 }}
                  value={sliderValue} 
                  onChange={handleSliderChange}
                />
              </Box>
            </>
          ) : (
            <Typography
              variant="h6"
              sx={{
                textAlign: 'center',
                color: 'error.main',
                marginTop: 2,
              }}
            >
              Ï≤òÎ¶¨Îêú ÎèôÏòÅÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§.
            </Typography>
          )}
        </Box>

        <Box sx={{ width: "25%", padding: 2 }}>
        <Tabs value={value} onChange={handleTabChange2} sx={{ marginBottom: 2 }}>
          <Tab label="Ïú†Ìï¥ÏöîÏÜå" />
          <Tab label="Í∞úÏù∏Ï†ïÎ≥¥" />
          <Tab label="ÏÇ¨Îûå" />
        </Tabs>

        {/* Í≥µÌÜµ UI */}
        {["harmful", "privacy", "person"].map((tab, index) =>
          value === index && (
            <Box key={tab}>
              <Typography variant="h6">ÎßàÏä§ÌÅ¨ ÏÑ§Ï†ï</Typography>
              <FormControlLabel
                control={<Checkbox checked={settings[tab].mosaic} onChange={(e) => handleCheckboxChange(tab, "mosaic", e)} />}
                label="Î™®ÏûêÏù¥ÌÅ¨"
              />
              <FormControlLabel
                control={<Checkbox checked={settings[tab].blur} onChange={(e) => handleCheckboxChange(tab, "blur", e)} />}
                label="Î∏îÎü¨"
              />
              <Typography variant="h6">ÎßàÏä§ÌÅ¨ Í∞ïÎèÑ</Typography>
              <Slider value={settings[tab].intensity} onChange={handleSliderChange2(tab, "intensity")} />
              <Typography variant="h6">ÎßàÏä§ÌÅ¨ ÌÅ¨Í∏∞</Typography>
              <Slider value={settings[tab].size} onChange={handleSliderChange2(tab, "size")} />

              {/* ÏÇ¨Îûå ÌÉ≠ÏóêÏÑúÎßå ÎßàÏä§ÌÅ¨ Ï≤¥ÌÅ¨ ÌëúÏãú */}
              {tab === "person" && (
                <>
                  <Typography variant="h6">ÎßàÏä§ÌÅ¨ Ï≤¥ÌÅ¨</Typography>
                  {["ÏÇ¨Îûå 1", "ÏÇ¨Îûå 2", "ÏÇ¨Îûå 3"].map((person) => (
                    <FormControlLabel
                      key={person}
                      control={
                        <Checkbox
                          checked={settings.person.checkedPeople.includes(person)}
                          onChange={handlePersonCheck(person)}
                        />
                      }
                      label={person}
                    />
                  ))}
                </>
              )}
            </Box>
          )
        )}
        </Box>
      </Box>

      <Stack direction="row" spacing={2} sx={{ marginTop: 2, justifyContent: 'center' }}>
        <Button variant="contained" color="primary" component={Link} to="/edit">
          ÎèåÏïÑÍ∞ÄÍ∏∞
        </Button>
        <Button variant="outlined" color="secondary" onClick={() => {/* Îã§Î•∏ ÎèôÏûë */}}>
          Ìé∏ÏßëÏôÑÎ£å
        </Button>
      </Stack>
    </AppTheme>
  );
}